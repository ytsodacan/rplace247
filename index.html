<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Neuro.Place</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;display=swap"
        rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <style>
        /* Existing body styles from the first style block */
        html,
        body {
            height: 100%;
            /* Make html and body take full viewport height */
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* Prevent scrolling on the entire page */
            font-family: 'Inter', sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            /* Ensure body is a flex container for its children */
            background-color: #f0f0f0;
            /* Light gray background for better contrast with grid */
            color: #333;
            /* Dark text for contrast on light background */
            height: 100vh;
            /* Ensure body takes full viewport height */
        }

        /* Ensure the main content area (everything between header and footer) grows to fill space */
        .flex-container-for-main-sections {
            flex-grow: 1;
            /* This makes this container take all available vertical space */
            display: flex;
            /* Makes its children (aside, main) flex items */
            min-height: 0;
            /* CRITICAL: Allows this flex item to shrink vertically if needed */
            overflow: hidden;
            /* Prevent scrollbars from app-container itself */
            position: relative;
            /* For absolutely positioned canvas inside it (if used) */
        }

        /* Adjust live view and chat log heights within left panel */
        #liveViewCanvas {
            width: 250px;
            /* 500 grid cells / 2 = 250px wide */
            height: 250px;
            /* 500 grid cells / 2 = 250px high */
            max-width: 100%;
            /* Ensure it doesn't overflow horizontally */
            border: 1px solid #555;
            background-color: #1a1a1a;
            /* Dark background for live view */
            display: block;
            /* Remove extra space below canvas */
            image-rendering: pixelated;
        }

        #pixelChatLog {
            flex-grow: 1;
            /* Allow log to take remaining space */
            overflow-y: auto;
            /* Enable scrolling for the log itself */
            word-break: break-all;
            min-height: 50px;
            /* Ensure a minimum visible height for the log */
            background-color: #ffffff;
            /* Dark background */
            border: 1px solid #555;
            padding: 10px;
            color: #000000;
            font-family: monospace;
            /* Monospace font for readability of coords */
            font-size: 0.9em;
            border-radius: 5px;
            line-height: 1.4;
            /* Spacing between lines */
        }

        #pixelChatLog p {
            margin: 0;
            /* Remove default paragraph margins */
            padding: 2px 0;
            /* Small vertical padding for each log entry */
            word-wrap: break-word;
            /* Wrap long lines if they somehow occur */
        }

        #pixelChatLog p:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.05);
            /* Slight stripe for readability */
        }


        /* Ensure main canvas container stretches */
        #main-content {
            flex-grow: 1;
            /* Ensure main content fills available horizontal space within flex-container-for-main-sections */
            min-height: 0;
            /* CRITICAL: Allows the main content flex item to shrink vertically */
            overflow: hidden;
            /* Prevents internal content from pushing main-content out */
            position: relative;
            /* Crucial for absolute positioning of rplaceCanvas inside */
        }

        #main-content>div {
            /* This is the bg-gray-500 div wrapping the canvas */
            height: 100%;
            /* Make the canvas wrapper take full height of main-content */
            width: 100%;
            /* Make the canvas wrapper take full width of main-content */
            position: relative;
            /* Ensure this div provides positioning context for absolute canvas if needed */
        }

        #left-panel {
            min-height: 0;
            /* CRITICAL: Allows left panel to shrink vertically if needed */
            width: 280px;
            /* Fixed width for the live view panel (500/2 + padding) */

            color: #eee;
            padding: 10px;
            box-sizing: border-box;
            /* Include padding in width */
            display: flex;
            flex-direction: column;
            /* Stack Live View and Pixel Log vertically */
            align-items: stretch;
            /* Changed from center to stretch to allow full width */
            z-index: 5;
            /* Ensure it's above other elements if necessary */
            border-right: 1px solid #555;
            overflow-y: auto;
            flex-shrink: 0;
            /* Prevent it from shrinking */
            overflow-x: clip;
            /* removing the left to right scrollbar for this pannel */
        }

        #left-panel h2 {
            /* Changed from h3 to h2 to match HTML */
            margin-top: 25px;
            margin-bottom: 10px;
            /* Adjusted spacing */
            color: #000000;
            text-align: center;
        }

        /* rplaceCanvas styles adjusted to fill its parent #main-content */
        #rplaceCanvas {
            display: block;
            background-color: #a3a3a3;
            cursor: grab;
            /* Indicate draggable */
            position: absolute;
            /* Changed to absolute to fill #main-content */
            top: 0;
            left: 0;
            width: 100%;
            /* Fill parent */
            height: 100%;
            z-index: 1;
            /* Crucial for keeping pixels sharp when scaled */
            image-rendering: pixelated;
        }

        /* Existing bottom-bar, controls, etc. styles */
        .bottom-bar {
            position: relative;
            /* Changed from fixed to relative as it's within flex context */
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #a3a3a3;
            color: #eee;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            z-index: 10;
            border-top: 1px solid #555;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .controls label {
            font-weight: bold;
            margin-right: 5px;
        }

        .controls input[type="color"] {
            border: none;
            padding: 0;
            width: 35px;
            height: 35px;
            cursor: pointer;
            background: none;
            -webkit-appearance: none;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            top: 2px;
            /* Slight adjustment for alignment */
        }

        /* For better color picker appearance across browsers */
        .controls input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .controls input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 5px;
        }

        .controls button {
            background-color: #007bff;
            /* Primary blue button */
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }

        .controls button:hover {
            background-color: #0056b3;
        }

        .zoom-controls {
            display: flex;
            gap: 5px;
        }

        .zoom-controls button {
            width: 35px;
            height: 35px;
            padding: 0;
            font-size: 1.2em;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .selected-coords {
            font-size: 1.1em;
            font-weight: bold;
            color: #9aff9a;
            /* Light green for coordinates */
        }

        /* Cursor change when dragging */
        .grabbing {
            cursor: grabbing !important;
        }

        .neuro {
            display: none;
        }

        /* Mobile support media query */
        @media (max-width: 768px) {

            /* Hide the entire left panel on screens 768px wide or narrower */
            #left-panel {
                display: none;
            }

            /* Adjust the main app container layout for mobile */
            .flex-container-for-main-sections {
                /* Changed from #app-container to match your HTML */
                flex-direction: column;
                /* Stack main content vertically instead of side-by-side */
            }

            /* Make the main content area take up the full width and height when the left panel is gone */
            #main-content {
                width: 100%;
                height: 100%;
                flex-grow: 1;
                /* Ensure it expands to fill available space */
            }



            /* Adjust footer/bottom bar for better mobile usability */
            footer>div {
                /* Target the inner div of the footer for flex layout */
                flex-direction: column;
                /* Stack items vertically */
                gap: 10px;
                /* Add some space between stacked items */
                padding: 10px;
                /* Adjust padding */
            }

            .selected-coords {
                width: 100%;
                /* Make controls take full width */
                justify-content: center;
                /* Center items within their full width */
            }

            .controls {
                flex-wrap: wrap;
                /* Allow controls to wrap to next line if necessary */
            }

            .selected {
                display: none;
            }

            .place {
                display: block;
            }

            .zoomin,
            .zoomout,
            .zoom-controls {
                display: none;
            }

            #rplaceCanvas {
                display: block;
                background-color: #a3a3a3;
                cursor: grab;
                /* Indicate draggable */
                position: absolute;
                /* Changed to absolute to fill #main-content */
                top: 0;
                left: 0;
                width: 100%;
                /* Fill parent */
                height: 100%;
                /* Fill parent */
                z-index: 1;
                /* Crucial for keeping pixels sharp when scaled */
                image-rendering: pixelated;
                image-rendering: crisp-edges;
                image-rendering: -moz-crisp-edges;
            }

            .header {
                display: none;
            }

            .neuro {
                display: flex;
            }
        }

        @media (max-width: 768px) {
            .place {
                display: block;
            }
        }
    </style>
</head>

<body class="bg-gray-100 flex flex-col">

    <header class="bg-gray-200 shadow-md py-4 header">
        <div class="container mx-auto px-4">
            <h1 class="text-3xl font-bold text-gray-800 text-center">Neuro.Place</h1>
        </div>
    </header>

    <div class="flex-container-for-main-sections ">
        <aside id="left-panel" class="w-[280px] bg-gray-200 shadow-md p-4 flex flex-col space-y-4 ">
            <h2 class="text-xl font-semibold text-gray-800">Live View</h2>
            <canvas id="liveViewCanvas" class="w-full border border-gray-300 rounded-md"></canvas>

            <h2 class="text-xl font-semibold text-gray-800 mt-4">Pixel Log</h2>
            <div id="pixelChatLog" class="bg-gray-50 p-2 rounded-md text-sm">
            </div>
        </aside>

        <main id="main-content" class="flex items-center justify-center">
            <div class="bg-gray-500 w-full h-full rounded-lg shadow-lg overflow-hidden">
                <canvas id="rplaceCanvas" class="w-full h-full"></canvas>
            </div>
        </main>
    </div>

    <footer class="bg-gray-200 py-4">
        <div class="container mx-auto px-4 flex justify-between items-center">
            <div class="flex items-center space-x-4">
                <label for="colorPicker" class="text-gray-700 font-medium">Color:</label>
                <input type="color" id="colorPicker" value="#000000"
                    class="w-10 h-10 rounded-md cursor-pointer border-2 border-gray-300 hover:border-blue-500 transition-colors">

                <span class="text-gray-700 text-lg selected">Selected: <span id="selectedCoords">(None)</span></span>
                <button id="placePixelBtn"
                    class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition-colors focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 place">
                    Place
                </button>

                <div id="authSection" class="flex items-center space-x-2">
                    <button id="discordLoginBtn"
                        class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                        Login with Discord
                    </button>
                    <div id="userInfo" class="hidden flex items-center space-x-2">
                        <img id="userAvatar" class="w-8 h-8 rounded-full" alt="User Avatar">
                        <span id="userName" class="text-gray-700 font-medium"></span>
                        <button id="logoutBtn" class="text-gray-500 hover:text-gray-700 text-sm">Logout</button>
                    </div>
                </div>
            </div>
            <h1 class="text-3xl font-bold text-gray-800 text-center neuro">Neuro.Place</h1>
        </div>
    </footer>

    <!-- Use module script pointing to cloud bundle -->
    <script type="module" src="script-cloud.js"></script>
    <script>document.addEventListener('DOMContentLoaded', () => {

            // --- Configuration ---
            const BACKEND_URL = 'https://place-worker.afunyun.workers.dev';
            const WEBSOCKET_URL = 'wss://place-worker.afunyun.workers.dev/ws';
            const DISCORD_WEBHOOK_URL = 'https://discord.com/api/webhooks/1388700167170953377/ovEsmIGQyGRU2Cu3mEAT4RtdkWYpOM-OKic_lzVFZmP0W1ofvIAJtpxkGYiu7zGFr83a';
            const OAUTH_CLIENT_ID = '1388712213002457118';
            const OAUTH_REDIRECT_URI = `${window.location.origin}/auth/callback`;

            const PIXEL_SIZE = 10; // Base size of each pixel in main grid coordinates

            // --- Live View Configuration ---
            const LIVE_VIEW_PIXEL_SIZE_FACTOR = 2; // For a 500x500 grid, live view will be 250x250 pixels.
            const LIVE_VIEW_CANVAS_WIDTH = 500 / LIVE_VIEW_PIXEL_SIZE_FACTOR; // Should be 250
            const LIVE_VIEW_CANVAS_HEIGHT = 500 / LIVE_VIEW_PIXEL_SIZE_FACTOR; // Should be 250

            const CLICK_THRESHOLD = 5; // Maximum pixel movement to still be considered a click/tap


            // --- DOM Elements (Main Canvas) ---
            const canvas = document.getElementById('rplaceCanvas');
            const ctx = canvas.getContext('2d');

            // --- DOM Elements (Live View Canvas) ---
            const liveViewCanvas = document.getElementById('liveViewCanvas');
            const liveViewCtx = liveViewCanvas.getContext('2d');

            // --- DOM Element for Pixel Chat Log ---
            const pixelChatLog = document.getElementById('pixelChatLog');

            // --- DOM Elements (Color Picker & Buttons) ---
            const colorPicker = document.getElementById('colorPicker');
            const customColorSwatch = document.getElementById('customColorSwatch'); // Assuming you have this, if not, it will be null
            const placePixelBtn = document.getElementById('placePixelBtn');
            const selectedCoordsDisplay = document.getElementById('selectedCoords');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');


            // --- Global State ---
            let currentColor = colorPicker.value;
            let gridData = [];
            let selectedPixel = { x: null, y: null };

            // WebSocket instance reference
            let socket = null;
            let reconnectAttempts = 0;
            const MAX_RECONNECT_ATTEMPTS = 5;
            const RECONNECT_DELAY = 1000;
            const sessionId = generateSessionId();
            let userToken = localStorage.getItem('discord_token');
            let userData = JSON.parse(localStorage.getItem('user_data') || 'null');

            // Make OAuth functions globally accessible
            window.initiateDiscordOAuth = () => initiateDiscordOAuth();
            window.logout = () => logout();
            window.handleOAuthCallback = () => handleOAuthCallback();

            // --- Canvas Dimensions (Must match backend grid dimensions) ---
            const GRID_WIDTH = 500;
            const GRID_HEIGHT = 500;

            // --- Viewport Transform State (for Main Canvas Pan & Zoom) ---
            let scale = 1.0;
            let offsetX = 0;
            let offsetY = 0;

            // --- Mouse Interaction State ---
            let isDragging = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            let lastClickX = 0;
            let lastClickY = 0;

            // --- Touch Interaction State ---
            let initialPinchDistance = null;
            let lastTouchX = 0;
            let lastTouchY = 0;
            let touchStartX = 0;
            let touchStartY = 0;

            // --- New: Offscreen Canvas for Main Grid (for faster drawing) ---
            let offscreenCanvas;
            let offscreenCtx;

            // --- New: ImageData for Live View (for even faster drawing) ---
            let liveViewImageData;
            let liveViewPixelData; // This will hold the Uint8ClampedArray for ImageData manipulation

            // --- Canvas Setup and Resizing ---
            function setCanvasSize() {
                const mainContentDiv = document.getElementById('main-content');
                if (mainContentDiv) {
                    canvas.width = mainContentDiv.clientWidth;
                    canvas.height = mainContentDiv.clientHeight;
                } else {
                    // Fallback for cases where main-content might not be available or fully rendered yet
                    const leftPanel = document.getElementById('left-panel');
                    const leftPanelWidth = leftPanel ? leftPanel.offsetWidth : 0;
                    canvas.width = window.innerWidth - leftPanelWidth;

                    const footerElement = document.querySelector('footer');
                    const footerHeight = footerElement ? footerElement.offsetHeight : 0;
                    canvas.height = window.innerHeight - footerHeight;
                }

                if (liveViewCanvas) {
                    liveViewCanvas.width = LIVE_VIEW_CANVAS_WIDTH;
                    liveViewCanvas.height = LIVE_VIEW_CANVAS_HEIGHT;
                }

                if (gridData && gridData.length > 0) {
                    console.log('setCanvasSize: Redrawing grids due to resize and existing data.');
                    drawGrid(); // No longer passes gridData directly
                    drawLiveViewGrid(); // No longer passes gridData directly
                } else {
                    console.log('setCanvasSize: Grid data not yet available for redraw.');
                }
            }

            // --- Utility: Convert Hex color to RGBA Array ---
            function hexToRgba(hex) {
                const bigint = parseInt(hex.slice(1), 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return [r, g, b, 255]; // Always opaque (alpha = 255)
            }

            // --- Backend Communication Functions ---

            async function getGrid() {
                try {
                    const response = await fetch(`${BACKEND_URL}/grid`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    console.log('Initial grid fetched successfully.');
                    return data;
                } catch (error) {
                    console.error('Error fetching grid:', error);
                    alert('Could not connect to backend to get initial grid. Is your backend running?');
                    return Array(GRID_HEIGHT).fill(0).map(() => Array(GRID_WIDTH).fill('#1a1a1a')); // Fallback to black grid
                }
            }

            async function placePixel(x, y, color) {
                try {
                    const headers = { 'Content-Type': 'application/json' };
                    if (userToken) {
                        headers.Authorization = `Bearer ${userToken}`;
                    }

                    const response = await fetch(`${BACKEND_URL}/pixel`, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify({
                            x,
                            y,
                            color,
                            sessionId,
                            user: userData
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Failed to place pixel: ${errorData.message || response.statusText}`);
                    }
                    console.log(`Pixel placement request sent for (${x}, ${y}) with color ${color}`);

                    // Send webhook notification
                    await sendWebhookNotification(x, y, color);
                } catch (error) {
                    console.error('Error sending pixel update:', error);
                    alert(`Failed to place pixel: ${error.message}`);
                }
            }

            // --- Canvas Drawing Functions (Main View - Optimized) ---

            // Draws a single pixel onto the OFFSCREEN canvas
            function drawPixelToOffscreen(x, y, color) {
                if (!offscreenCtx) {
                    console.error("Offscreen canvas context not available for drawPixel.");
                    return;
                }
                offscreenCtx.fillStyle = color;
                offscreenCtx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
            }

            // Draws the entire grid data onto the OFFSCREEN canvas initially
            function drawFullOffscreenGrid(grid) {
                if (!offscreenCtx || !offscreenCanvas) return;
                offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        if (grid[y] && grid[y][x] !== undefined) {
                            drawPixelToOffscreen(x, y, grid[y][x]);
                        }
                    }
                }
                console.log('Full grid drawn to offscreen canvas.');
            }

            // Draws the visible portion of the OFFSCREEN canvas onto the MAIN canvas
            function drawGrid() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear main canvas

                if (!offscreenCanvas) return;

                ctx.save();
                ctx.translate(offsetX, offsetY); // Apply pan
                ctx.scale(scale, scale);       // Apply zoom

                // Draw the offscreen canvas (entire grid) onto the main canvas.
                // The translate and scale applied above will handle which portion is visible and at what size.
                ctx.drawImage(offscreenCanvas, 0, 0);

                ctx.restore(); // Restore context to prevent transforms affecting other elements

                // Highlight drawing (this is correctly applying transforms after restore)
                if (selectedPixel.x !== null && selectedPixel.y !== null) {
                    ctx.save();
                    ctx.translate(offsetX, offsetY);
                    ctx.scale(scale, scale);
                    ctx.strokeStyle = 'var(--gd-highlight-color, orange)'; // Default to orange if CSS var not found
                    // Line width needs to be adjusted by inverse scale to appear consistent regardless of zoom
                    ctx.lineWidth = 3 / scale;
                    ctx.strokeRect(selectedPixel.x * PIXEL_SIZE, selectedPixel.y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                    ctx.restore();
                }
            }

            // --- Canvas Drawing Functions (Live View - Optimized) ---

            // Initializes ImageData for the live view canvas
            function initLiveViewImageData() {
                liveViewImageData = liveViewCtx.createImageData(LIVE_VIEW_CANVAS_WIDTH, LIVE_VIEW_CANVAS_HEIGHT);
                liveViewPixelData = liveViewImageData.data; // This is a Uint8ClampedArray
            }

            // Draws the entire grid data onto the LIVE VIEW canvas using ImageData
            function drawLiveViewGrid() { // No longer takes grid as argument, uses global gridData
                if (!liveViewCtx || !liveViewPixelData) {
                    console.error("Live View Canvas Context or ImageData not available.");
                    return;
                }

                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const color = gridData[y] && gridData[y][x] !== undefined ? gridData[y][x] : '#000000'; // Default to black
                        const [r, g, b, a] = hexToRgba(color);

                        // Calculate target pixel on live view canvas (it's 1x1 here)
                        const targetX = Math.floor(x / LIVE_VIEW_PIXEL_SIZE_FACTOR);
                        const targetY = Math.floor(y / LIVE_VIEW_PIXEL_SIZE_FACTOR);

                        const imageDataIndex = (targetY * LIVE_VIEW_CANVAS_WIDTH + targetX) * 4;

                        // Ensure the index is within bounds before writing
                        if (imageDataIndex >= 0 && imageDataIndex + 3 < liveViewPixelData.length) {
                            liveViewPixelData[imageDataIndex] = r;
                            liveViewPixelData[imageDataIndex + 1] = g;
                            liveViewPixelData[imageDataIndex + 2] = b;
                            liveViewPixelData[imageDataIndex + 3] = a;
                        }
                    }
                }
                liveViewCtx.putImageData(liveViewImageData, 0, 0); // Re-draw the entire live view (fast for small canvas)
            }

            // --- Utility Functions ---
            function generateSessionId() {
                return `session_${Math.random().toString(36).substring(2, 11)}${Date.now().toString(36)}`;
            }

            // --- OAuth Authentication ---
            function initiateDiscordOAuth() {
                const scopes = 'identify';
                const oauthUrl = `https://discord.com/api/oauth2/authorize?client_id=${OAUTH_CLIENT_ID}&redirect_uri=${encodeURIComponent(OAUTH_REDIRECT_URI)}&response_type=code&scope=${encodeURIComponent(scopes)}`;
                window.location.href = oauthUrl;
            }

            async function handleOAuthCallback() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');

                if (code) {
                    try {
                        const response = await fetch(`${BACKEND_URL}/auth/discord`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ code, redirect_uri: OAUTH_REDIRECT_URI })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            userToken = data.access_token;
                            userData = data.user;
                            localStorage.setItem('discord_token', userToken);
                            localStorage.setItem('user_data', JSON.stringify(userData));
                            updateUserInterface();
                            // Clean up URL
                            window.history.replaceState({}, document.title, window.location.pathname);
                        }
                    } catch (error) {
                        console.error('OAuth callback error:', error);
                    }
                }
            }

            function logout() {
                userToken = null;
                userData = null;
                localStorage.removeItem('discord_token');
                localStorage.removeItem('user_data');
                updateUserInterface();
            }

            function updateUserInterface() {
                const loginBtn = document.getElementById('login-btn');
                const logoutBtn = document.getElementById('logout-btn');
                const userInfo = document.getElementById('user-info');

                if (userData && userToken) {
                    if (loginBtn) loginBtn.style.display = 'none';
                    if (logoutBtn) logoutBtn.style.display = 'inline-block';
                    if (userInfo) {
                        userInfo.style.display = 'block';
                        userInfo.innerHTML = `
                    <img src="https://cdn.discordapp.com/avatars/${userData.id}/${userData.avatar}.png" 
                         alt="Avatar" width="32" height="32" style="border-radius: 50%;">
                    <span>${userData.username}#${userData.discriminator}</span>
                `;
                    }
                } else {
                    if (loginBtn) loginBtn.style.display = 'inline-block';
                    if (logoutBtn) logoutBtn.style.display = 'none';
                    if (userInfo) userInfo.style.display = 'none';
                }
            }

            // --- Webhook Integration ---
            async function sendWebhookNotification(x, y, color) {
                try {
                    const username = userData ? `${userData.username}#${userData.discriminator}` : 'Anonymous';
                    const payload = {
                        content: `ðŸŽ¨ **${username}** placed a pixel!`,
                        username: "Neuro.Place Bot",
                        avatar_url: "https://cdn.discordapp.com/app-icons/your-app-id/icon.png",
                        embeds: [{
                            title: "New Pixel Placed",
                            color: parseInt(color.slice(1), 16),
                            fields: [
                                { name: "Coordinates", value: `(${x}, ${y})`, inline: true },
                                { name: "Color", value: color, inline: true },
                                { name: "User", value: username, inline: true }
                            ],
                            timestamp: new Date().toISOString(),
                            thumbnail: userData ? {
                                url: `https://cdn.discordapp.com/avatars/${userData.id}/${userData.avatar}.png`
                            } : undefined
                        }]
                    };

                    await fetch(DISCORD_WEBHOOK_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(userToken && { 'Authorization': `Bearer ${userToken}` })
                        },
                        body: JSON.stringify(payload)
                    });
                } catch (error) {
                    console.warn('Failed to send Discord webhook notification:', error);
                }
            }

            // --- Pixel Log Function ---
            function addPixelLogEntry(x, y, color) {
                if (!pixelChatLog) {
                    console.error("Pixel chat log element not found.");
                    return;
                }

                const logEntry = document.createElement('p');
                // Basic check for string x,y for "System" messages
                const displayX = typeof x === 'number' ? x : 'System';
                const displayY = typeof y === 'number' ? y : (y === 'Connected' || y === 'Disconnected' || y === 'Reconnectingâ€¦' || y.startsWith('Connection Error')) ? '' : y;

                logEntry.innerHTML = `(<span style="color: lightblue;">${displayX}</span>, <span style="color: lightblue;">${displayY}</span>) set to <span style="color: ${color}; font-weight: bold;">${color}</span>`;
                pixelChatLog.appendChild(logEntry);

                pixelChatLog.scrollTop = pixelChatLog.scrollHeight;
            }


            // --- Event Handlers (Mouse & Touch) ---

            // Corrected getGridCoordsFromScreen: relies solely on canvas.getBoundingClientRect()
            // and inverse transforms, assuming no direct border/padding on canvas itself.
            function getGridCoordsFromScreen(clientX, clientY) {
                const rect = canvas.getBoundingClientRect();

                // These calculations should be correct if rect.left/top correctly represent the
                // top-left of the canvas's drawing area in screen coordinates.
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;

                // Apply inverse of current offset and scale
                const worldX = (canvasX - offsetX) / scale;
                const worldY = (canvasY - offsetY) / scale;

                // Convert world coordinates (scaled pixel values) to grid coordinates
                const gridX = Math.floor(worldX / PIXEL_SIZE);
                const gridY = Math.floor(worldY / PIXEL_SIZE);

                console.log('--- getGridCoordsFromScreen Debug ---');
                console.log(`Input Screen: (${clientX}, ${clientY})`);
                console.log(`Canvas Bounding Rect: left=${rect.left.toFixed(2)}, top=${rect.top.toFixed(2)}, width=${rect.width.toFixed(2)}, height=${rect.height.toFixed(2)}`); // Added width/height for more context
                console.log(`Canvas Local (relative to canvas top-left): (${canvasX.toFixed(2)}, ${canvasY.toFixed(2)})`);
                console.log(`Current Transform: offsetX=${offsetX.toFixed(2)}, offsetY=${offsetY.toFixed(2)}, scale=${scale.toFixed(2)}`);
                console.log(`World (after inverse transform): X=${worldX.toFixed(2)}, Y=${worldY.toFixed(2)}`);
                console.log(`Grid Coords (final result): (${gridX}, ${gridY})`);
                console.log('------------------------------------');

                if (gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {
                    return { x: gridX, y: gridY };
                }
                return null;
            }

            function handleUserInteractionClick(event) {
                const currentX = event.clientX;
                const currentY = event.clientY;

                const coords = getGridCoordsFromScreen(currentX, currentY);

                if (coords) {
                    if (selectedPixel.x !== coords.x || selectedPixel.y !== coords.y) {
                        // console.log('DEBUG: SELECTED PIXEL CHANGING!', {old: selectedPixel, new: coords});
                    }
                    selectedPixel = { x: coords.x, y: coords.y };
                    updateSelectedCoordsDisplay();
                    drawGrid(); // Redraw main canvas to show highlight
                } else {
                    if (selectedPixel.x !== null) {
                        // console.log('DEBUG: SELECTED PIXEL CLEARED!', {old: selectedPixel, new: null});
                    }
                    selectedPixel = { x: null, y: null };
                    updateSelectedCoordsDisplay();
                    drawGrid(); // Redraw main canvas to remove highlight
                }
            }

            // Mouse Handlers
            function handleMouseDown(event) {
                isDragging = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                lastClickX = event.clientX;
                lastClickY = event.clientY;
                canvas.classList.add('grabbing');
                // console.log('DEBUG: Mouse Down - Starting interaction. Stored start coords:', lastClickX, lastClickY);
            }

            function handleMouseMove(event) {
                if (!isDragging) {
                    return;
                }

                const dx = event.clientX - lastMouseX;
                const dy = event.clientY - lastMouseY;

                offsetX += dx;
                offsetY += dy;

                // Round offsets to nearest integer pixel to help alignment
                offsetX = Math.round(offsetX);
                offsetY = Math.round(offsetY);

                lastMouseX = event.clientX;
                lastMouseY = event.clientY;

                drawGrid(); // Redraw main canvas
            }

            function handleMouseUp(event) {
                isDragging = false;
                canvas.classList.remove('grabbing');
                // console.log('DEBUG: Mouse Up - Ending interaction.');

                const dx = event.clientX - lastClickX;
                const dy = event.clientY - lastClickY;

                if (Math.abs(dx) < CLICK_THRESHOLD && Math.abs(dy) < CLICK_THRESHOLD) {
                    // console.log('DEBUG: Mouse Up - Detected as a click. Calling handleUserInteractionClick with start coords.');
                    handleUserInteractionClick({ clientX: lastClickX, clientY: lastClickY });
                } else {
                    // console.log('DEBUG: Mouse Up - Detected as a drag. No selection change.');
                }
            }

            // Touch Handlers
            function handleTouchStart(event) {
                event.preventDefault();

                if (event.touches.length === 1) {
                    isDragging = true;
                    lastTouchX = event.touches[0].clientX;
                    lastTouchY = event.touches[0].clientY;
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                    canvas.classList.add('grabbing');
                    initialPinchDistance = null;
                    // console.log('DEBUG: Touch Start - Single touch (potential drag/tap). Stored start coords:', touchStartX, touchStartY);
                } else if (event.touches.length === 2) {
                    isDragging = false;
                    initialPinchDistance = getPinchDistance(event);
                    // console.log('DEBUG: Touch Start - Two touches (potential pinch-to-zoom). initialPinchDistance:', initialPinchDistance);
                } else {
                    // console.log('DEBUG: Touch Start - More than 2 touches. Ignoring.');
                }
            }

            function handleTouchMove(event) {
                event.preventDefault();

                if (event.touches.length === 1 && isDragging) {
                    const dx = event.touches[0].clientX - lastTouchX;
                    const dy = event.touches[0].clientY - lastTouchY;

                    offsetX += dx;
                    offsetY += dy;

                    // Round offsets to nearest integer pixel
                    offsetX = Math.round(offsetX);
                    offsetY = Math.round(offsetY);

                    lastTouchX = event.touches[0].clientX;
                    lastTouchY = event.touches[0].clientY;

                    drawGrid(); // Redraw main canvas
                } else if (event.touches.length === 2 && initialPinchDistance !== null) {
                    const currentPinchDistance = getPinchDistance(event);
                    const scaleChange = currentPinchDistance / initialPinchDistance;

                    const oldScale = scale;
                    scale *= scaleChange;
                    scale = Math.max(0.1, Math.min(scale, 10.0));

                    const touchCenterX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
                    const touchCenterY = (event.touches[0].clientY + event.touches[1].clientY) / 2;

                    const rect = canvas.getBoundingClientRect();
                    const mouseCanvasX = touchCenterX - rect.left;
                    const mouseCanvasY = touchCenterY - rect.top;

                    const mouseWorldX = (mouseCanvasX - offsetX) / oldScale;
                    const mouseWorldY = (mouseCanvasY - offsetY) / oldScale;

                    offsetX = mouseCanvasX - mouseWorldX * scale;
                    offsetY = mouseCanvasY - mouseWorldY * scale;

                    // Round offsets to nearest integer pixel
                    offsetX = Math.round(offsetX);
                    offsetY = Math.round(offsetY);

                    initialPinchDistance = currentPinchDistance;
                    drawGrid(); // Redraw main canvas
                    // console.log(`DEBUG: Touch Move - Pinch-to-zoom. scale:${scale}, currentPinchDistance:${currentPinchDistance}`);
                }
            }

            function handleTouchEnd(event) {
                canvas.classList.remove('grabbing');
                isDragging = false;
                initialPinchDistance = null;
                // console.log('DEBUG: Touch End - Ending interaction.');

                if (event.changedTouches.length === 1) {
                    const finalX = event.changedTouches[0].clientX;
                    const finalY = event.changedTouches[0].clientY;

                    const dx = finalX - touchStartX;
                    const dy = finalY - touchStartY;

                    if (Math.abs(dx) < CLICK_THRESHOLD && Math.abs(dy) < CLICK_THRESHOLD) {
                        // console.log('DEBUG: Touch End - Detected as a tap. Calling handleUserInteractionClick with start coords.');
                        handleUserInteractionClick({ clientX: touchStartX, clientY: touchStartY });
                    } else {
                        // console.log('DEBUG: Touch End - Detected as a drag/swipe. No selection change.');
                    }
                }
            }

            function getPinchDistance(event) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                return Math.sqrt(
                    (touch2.clientX - touch1.clientX) ** 2 +
                    (touch2.clientY - touch1.clientY) ** 2
                );
            }


            function handleMouseWheel(event) {
                if (event.preventDefault) {
                    event.preventDefault();
                }

                const zoomFactor = 0.1;
                const oldScale = scale;

                if (event.deltaY < 0) { // Zoom in
                    scale *= (1 + zoomFactor);
                } else { // Zoom out
                    scale /= (1 + zoomFactor);
                }

                scale = Math.max(0.1, Math.min(scale, 10.0)); // Clamp scale

                const rect = canvas.getBoundingClientRect();
                const mouseCanvasX = event.clientX - rect.left;
                const mouseCanvasY = event.clientY - rect.top;

                // Calculate world coordinates of the mouse before zoom
                const mouseWorldX = (mouseCanvasX - offsetX) / oldScale;
                const mouseWorldY = (mouseCanvasY - offsetY) / oldScale;

                // Adjust offsetX and offsetY to keep the mouse point fixed after zoom
                offsetX = mouseCanvasX - mouseWorldX * scale;
                offsetY = mouseCanvasY - mouseWorldY * scale; // Corrected: was canvasY, now mouseCanvasY

                // Round offsets to nearest integer pixel
                offsetX = Math.round(offsetX);
                offsetY = Math.round(offsetY);

                drawGrid(); // Redraw main canvas
                // console.log(`DEBUG: Mouse Wheel - Zoom. deltaY:${event.deltaY}, new scale:${scale}, offsetX:${offsetX.toFixed(2)}, offsetY:${offsetY.toFixed(2)}`);
            }

            function handlePlacePixelClick() {
                if (selectedPixel.x !== null && selectedPixel.y !== null) {
                    placePixel(selectedPixel.x, selectedPixel.y, currentColor);
                } else {
                    alert('Please select a pixel on the canvas first!');
                }
            }

            function handleColorChange() {
                currentColor = colorPicker.value;
                if (customColorSwatch) {
                    customColorSwatch.style.backgroundColor = currentColor;
                }
            }

            function updateSelectedCoordsDisplay() {
                if (selectedPixel.x !== null && selectedPixel.y !== null) {
                    selectedCoordsDisplay.textContent = `(${selectedPixel.x}, ${selectedPixel.y})`;
                } else {
                    selectedCoordsDisplay.textContent = 'None';
                }
            }

            // Keyboard controls for desktop: arrow keys to move selection, spacebar to place pixel
            function handleKeyDown(event) {
                if (event.defaultPrevented) return; // Do nothing if event already handled
                switch (event.key) {
                    case 'ArrowUp':
                        if (selectedPixel.y > 0) selectedPixel.y--;
                        break;
                    case 'ArrowDown':
                        if (selectedPixel.y < GRID_HEIGHT - 1) selectedPixel.y++;
                        break;
                    case 'ArrowLeft':
                        if (selectedPixel.x > 0) selectedPixel.x--;
                        break;
                    case 'ArrowRight':
                        if (selectedPixel.x < GRID_WIDTH - 1) selectedPixel.x++;
                        break;
                    case ' ':
                    case 'Spacebar':
                    case 'Space':
                        event.preventDefault();
                        if (selectedPixel.x !== null && selectedPixel.y !== null) {
                            placePixel(selectedPixel.x, selectedPixel.y, currentColor);
                        }
                        return;
                    default:
                        return; // Exit for other keys
                }
                event.preventDefault();
                // Initialize selection if none
                if (selectedPixel.x === null || selectedPixel.y === null) {
                    selectedPixel.x = 0;
                    selectedPixel.y = 0;
                }
                updateSelectedCoordsDisplay();
                drawGrid();
            }
            // ...existing code...

            // --- WebSocket Setup ---

            function createReconnectButton() {
                const btn = document.createElement('button');
                btn.id = 'reconnectButton';
                btn.textContent = 'Reconnect';
                btn.style.display = 'none'; // Initially hidden
                btn.style.padding = '8px 15px';
                btn.style.marginLeft = '8px';
                btn.style.borderRadius = '5px';
                btn.style.fontWeight = 'bold';
                btn.style.cursor = 'pointer';
                btn.style.backgroundColor = '#4caf50';
                btn.style.color = '#fff';
                btn.style.border = 'none'; // Ensure no border from Tailwind is overriding

                btn.addEventListener('click', () => {
                    if (!socket) return;
                    addPixelLogEntry('System', 'Reconnectingâ€¦', '#ffff00');
                    btn.disabled = true;
                    connectWebSocket();
                });

                // Append to the same div as placePixelBtn for consistent layout
                if (placePixelBtn?.parentElement) {
                    placePixelBtn.parentElement.appendChild(btn);
                } else {
                    // Fallback if the footer structure is unexpected
                    document.body.appendChild(btn);
                }
                return btn;
            }

            function connectWebSocket() {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    return;
                }

                try {
                    socket = new WebSocket(WEBSOCKET_URL);

                    socket.onopen = () => {
                        console.log('Connected to backend WebSocket');
                        addPixelLogEntry('System', 'Connected', '#00ff00');
                        reconnectButton.style.display = 'none';
                        reconnectButton.disabled = false;
                        reconnectAttempts = 0;
                    };

                    socket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);

                            if (data.type === 'pixelUpdate') {
                                const { x, y, color } = data;

                                // 1. Update global gridData
                                if (gridData[y]?.[x] !== undefined) {
                                    gridData[y][x] = color;
                                }

                                // 2. Update offscreen canvas (for main view) for the specific pixel
                                drawPixelToOffscreen(x, y, color);

                                // 3. Update live view pixel directly in ImageData
                                if (liveViewPixelData) {
                                    const [r, g, b, a] = hexToRgba(color);
                                    const targetX = Math.floor(x / LIVE_VIEW_PIXEL_SIZE_FACTOR);
                                    const targetY = Math.floor(y / LIVE_VIEW_PIXEL_SIZE_FACTOR);
                                    const imageDataIndex = (targetY * LIVE_VIEW_CANVAS_WIDTH + targetX) * 4;

                                    if (imageDataIndex >= 0 && imageDataIndex + 3 < liveViewPixelData.length) {
                                        liveViewPixelData[imageDataIndex] = r;
                                        liveViewPixelData[imageDataIndex + 1] = g;
                                        liveViewPixelData[imageDataIndex + 2] = b;
                                        liveViewPixelData[imageDataIndex + 3] = a;
                                    }
                                    liveViewCtx.putImageData(liveViewImageData, 0, 0);
                                }

                                // 4. Redraw main grid
                                drawGrid();
                                addPixelLogEntry(x, y, color);
                            }
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                        }
                    };

                    socket.onclose = (event) => {
                        console.log('WebSocket connection closed:', event.code, event.reason);
                        addPixelLogEntry('System', 'Disconnected', '#ff0000');

                        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                            reconnectAttempts++;
                            console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                            setTimeout(() => connectWebSocket(), RECONNECT_DELAY * reconnectAttempts);
                        } else {
                            reconnectButton.style.display = 'inline-block';
                            alert('Connection lost. Please click reconnect to retry.');
                        }
                    };

                    socket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        addPixelLogEntry('System', 'Connection Error', '#ff9900');
                    };

                } catch (error) {
                    console.error('Failed to create WebSocket connection:', error);
                    addPixelLogEntry('System', `Connection Error: ${error.message}`, '#ff9900');
                    reconnectButton.style.display = 'inline-block';
                }
            }

            function setupWebSocket() {
                connectWebSocket();
            }


            // --- Initialization ---

            async function init() {
                if (customColorSwatch && colorPicker) {
                    customColorSwatch.style.backgroundColor = colorPicker.value;
                }

                setCanvasSize();

                offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = GRID_WIDTH * PIXEL_SIZE;
                offscreenCanvas.height = GRID_HEIGHT * PIXEL_SIZE;
                offscreenCtx = offscreenCanvas.getContext('2d');
                // Set image smoothing on the offscreen canvas context to false for crisp pixels
                offscreenCtx.imageSmoothingEnabled = false;
                console.log('Offscreen Canvas created.');

                if (liveViewCanvas) {
                    initLiveViewImageData();
                }
                // Also set image smoothing for the live view canvas for crisp pixels
                liveViewCtx.imageSmoothingEnabled = false;

                gridData = await getGrid();

                drawFullOffscreenGrid(gridData);

                const gridPixelWidth = GRID_WIDTH * PIXEL_SIZE;
                const gridPixelHeight = GRID_HEIGHT * PIXEL_SIZE;

                const fitScaleX = canvas.width / gridPixelWidth;
                const fitScaleY = canvas.height / gridPixelHeight;
                scale = Math.min(fitScaleX, fitScaleY) * 0.9; // Fit it with a small margin
                scale = Math.max(scale, 0.1); // Ensure it's not too small

                // Center the grid initially
                offsetX = (canvas.width - (gridPixelWidth * scale)) / 2;
                offsetY = (canvas.height - (gridPixelHeight * scale)) / 2;

                // Round initial offsets too
                offsetX = Math.round(offsetX);
                offsetY = Math.round(offsetY);

                // Set image smoothing on the main canvas context to false for crisp pixels when scaled
                ctx.imageSmoothingEnabled = false;

                drawGrid(); // Draws from offscreen
                drawLiveViewGrid(); // Draws using ImageData

                window.addEventListener('resize', setCanvasSize);
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);
                canvas.addEventListener('mouseout', handleMouseUp); // Ensure mouseup is called if dragging off canvas
                canvas.addEventListener('wheel', handleMouseWheel, { passive: false });
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd);
                canvas.addEventListener('touchcancel', handleTouchEnd); // Handle touches ending unexpectedly

                colorPicker.addEventListener('input', handleColorChange);
                if (customColorSwatch) { // Check if element exists before adding listener
                    customColorSwatch.addEventListener('click', () => { colorPicker.click(); });
                }
                placePixelBtn.addEventListener('click', handlePlacePixelClick);

                // When simulating wheel, use mouseCanvasX/Y as the center of zoom
                if (zoomInBtn) {
                    zoomInBtn.addEventListener('click', () => handleMouseWheel({
                        deltaY: -1,
                        clientX: canvas.getBoundingClientRect().left + canvas.width / 2, // Center of canvas in screen coords
                        clientY: canvas.getBoundingClientRect().top + canvas.height / 2, // Center of canvas in screen coords
                        preventDefault: () => { }
                    }));
                }
                if (zoomOutBtn) {
                    zoomOutBtn.addEventListener('click', () => handleMouseWheel({
                        deltaY: 1,
                        clientX: canvas.getBoundingClientRect().left + canvas.width / 2,
                        clientY: canvas.getBoundingClientRect().top + canvas.height / 2,
                        preventDefault: () => { }
                    }));
                }

                window.reconnectButton = createReconnectButton();

                updateSelectedCoordsDisplay();
                setupWebSocket();

                // Add keyboard event listener for arrow keys and spacebar
                document.addEventListener('keydown', handleKeyDown);

                // Handle OAuth callback and update UI
                await handleOAuthCallback();
                updateUserInterface();

                console.log('Frontend initialized!');
            }

            init();

        });
    </script>

</body>

</html>